# Wet-Dry Metrics


## Load settings

```{r include=FALSE}
source(here::here("project_settings.R"), echo=TRUE)
```


## Down-sampling 

Right now the files are logging every 10 minutes, which is too high of a resolution. Need to down-sample the dataset from 10min to some other interval that is meaningful to define states to.

12hrs seems too long given how far birds can move in this time, but 10min is far too short.

Tempted to use 2hr resolution to match GPS. 
For example, within each 2hr period we need to assess:

•	Proportion wet or time wet ((Count wets in 2hr period * 30sec) / 72000sec)
•	Number of switches between 0 and non-zero value
•	Total time when entire 10min sampling interval was dry (count 0s * 10min)
•	Total time when entire 10min sampling interval was wet (count >=1 * 10min)
•	Longest continuous time dry (longest number of consecutive rows with wets==0  * 10min)
•	Longest continuous time wet (longest number of consecutive rows with wets>=1 * 10min)

### 2hr Periods

```{r eval=FALSE}
if (FALSE) {
#made a new dir called downsampled in /data
source(here("utils/downsample_deg.R"), echo = F)

bin_time = 2

#define deg files to use
deg_files <- list.files(output.dir, pattern = "*.deg", full.names = TRUE)#[1:5] #add if you want to subset

#set up a furrr plan for using 4 cores
plan(multisession, workers = 4)

future_map(deg_files, downsample_deg, bin_time = bin_time)

plan(sequential)
}

```


This is what the deg files look like now:
```
date,start_time,end_time,wets
2022-09-08,00:00:00,01:59:59,0
2022-09-08,02:00:00,03:59:59,0
2022-09-08,04:00:00,05:59:59,0
2022-09-08,06:00:00,07:59:59,...
```


So our dataset's `wets` values now represent the average number of 10-minute intervals that were wet during the 2-hour period. This means each 2hr period has 12 intervals of 10 minutes (600 secs).

wets = 0 means 10min interval was entirely wet
wets = 20 means 10min interval was entirely dry

For one 10min interval,
if wets=1, then 600s/20 = 30 seconds
so 1 unit wets = 30 seconds wet per 10min interval


### 1hr Periods

```{r eval=FALSE}
if (FALSE) {
#made a new dir called downsampled in /data
source(here("utils/downsample_deg.R"), echo = F)

bin_time = 1

#define deg files to use
deg_files <- list.files(output.dir, pattern = "*.deg", full.names = TRUE)#[1:5] #add if you want to subset

#set up a furrr plan for using 4 cores
plan(multisession, workers = 4)

future_map(deg_files, downsample_deg, bin_time = bin_time)

plan(sequential)
}

```



## Reviewing Metadata

Make a table to review how many files we have per deployment period per colony:
```{r}
md <- read.csv(file.path(data.dir, "MasterMetadata_LHSP_Tracking_NL_NB_NS_13Aug2024.csv"))

colnames(md)

#clean up the metadata so that we only include the necessary columns for clipping
metrics_md <- md %>%
  
  filter(
    #filter for MT devices
    tagMake %in% c("Migrate Technology: W30A9-SEA", "Migrate Technology: W30A9-SEA-COOL"),
    #remove any NA rows in wetdry_filename 
    !is.na(wetdry_filename)) %>% 
  
  # merge estimated and observed columns 
  mutate(
    depDate_comb = as.Date(ifelse(!is.na(dep_dateEst), dep_dateEst, dep_date), format = "%Y-%m-%d"),
    retDate_comb = as.Date(
      ifelse(!is.na(ret_dateEst), substr(ret_dateEst, nchar(ret_dateEst) - 9, nchar(ret_dateEst)), 
             ret_date), format = "%Y-%m-%d")) %>%
  
  mutate(depDate_comb = as.Date(depDate_comb),
         retDate_comb = as.Date(retDate_comb)) %>%
  
  #only keep necessary columns 
  select(wetdry_filename, depDate_comb, retDate_comb, colony) %>%
  
  #fix fomratted name for that one DEG file i manually changed
  mutate(wetdry_filename = ifelse(
      wetdry_filename == "BH594_04Jul18_135310driftadj.deg",
      "BH594_formatted_04Jul18_135310driftadj.deg",
      wetdry_filename))  %>%
  
  #categorize deployment periods in the dtaaframe
  mutate(
    deployment_period = case_when(
    depDate_comb >= as.Date("2017-01-01") & retDate_comb <= as.Date("2018-12-31") ~ "2017-2018",
    depDate_comb >= as.Date("2018-01-01") & retDate_comb <= as.Date("2019-12-31") ~ "2018-2019",
    depDate_comb >= as.Date("2019-01-01") & retDate_comb <= as.Date("2020-12-31") ~ "2019-2020",
    depDate_comb >= as.Date("2020-01-01") & retDate_comb <= as.Date("2021-12-31") ~ "2020-2021",
    depDate_comb >= as.Date("2021-01-01") & retDate_comb <= as.Date("2022-12-31") ~ "2021-2022",
    depDate_comb >= as.Date("2022-01-01") & retDate_comb <= as.Date("2023-12-31") ~ "2022-2023",
      TRUE ~ "Other"   # any records outside of these ranges
    )
  )

deployment_summary <- metrics_md %>%
  
  group_by(deployment_period, colony) %>%
  
  summarise(file_count=n(), .groups = "drop") %>%
  
  pivot_wider(names_from = colony,  #make tibble with colony columns
              values_from = file_count, 
              values_fill = 0 # fill missing vals with 0
              ) %>%
  mutate(TOTAL = rowSums(select(., -deployment_period))) %>%
  
  bind_rows(summarise(.,
                      across(where(is.numeric), sum),
                      deployment_period = "TOTAL"))

deployment_summary

```


We want the following metrics for times the device was deployed:

* **Total proportion of time wet:** proportion of seconds wet across all 2-hour bins for the day, where (count of wets in each bin * 30 seconds) / 7200 seconds.

* **Total number of state switches (wet/dry transitions) per day:** number of times the device switched between wet (non-zero) and dry (zero) states across all 2-hour bins.

* **Cumulative dry and wet times per day:** total time (in seconds) the device recorded as completely dry (wets == 0) or wet (wets > 0) during the sampling intervals within the day.

* **Longest continuous periods of dry or wet states throughout the whoel deployment period:** longest sequence of consecutive 10-minute intervals within the entire deployment period where the device recorded



## Baccalieu - Ned Walsh 2017-2018

Decide what downsampled data you want to use based on the bin_time 
```{r}
(downsampled.dir <- file.path(data.dir, "downsampled_1hrs"))
```

Let's start with the 2017-2018 files from Baccalieu (6 files total)
```{r}
#get list of downsampled files to process 
bacc_2017_files <- metrics_md %>%
  filter(colony == "Baccalieu - Ned Walsh",
         deployment_period == "2017-2018") %>%
  pull(wetdry_filename)

bacc_2017_files <- paste0("filtered_", bacc_2017_files)
 
DEG_files <- list.files(downsampled.dir, full.names=TRUE)

bacc_2017_files <- DEG_files[basename(DEG_files) %in% bacc_2017_files]
```


### Proportion/Switches

Calculated by:
* **2hr Periods** - Finest resolution, 
* **Daily Periods** - Helps assess trends over long time periods, like looking at wet proportions/switches seasonally
* **Monthly Periods** - Lowest resolution ()

##### 2hr Periods

Calculate Proportions/Switches within each 2hr Bin


```{r}
calc_metrics <- function(file_path) {
  deg_data <- read_csv(file_path, show_col_types=FALSE)
  
  bird_id <- str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")
  
  #start by calculating metrics for a single 2hr bin
  metrics <- deg_data %>%
    mutate(
      bin_length = bin_time * 3600, #2hrs in secs
      
      #proportion of time wet in 2hr period (wets*30 converts wetness level into secs spent wet)
      # (600sec per 10min interval) / 20 = 30 seconds per unit 
      prop_wet = (wets * 30) / bin_length, 
      
      #switches between wet (non-zero) and dry (zero) states
      switches= ifelse(row_number() == 1,0,
                       abs(diff(ifelse(wets > 0, 1, 0)))),
      
      #cumulative time spent dry (== 0) or wet (>0)
      dry_time= ifelse(wets == 0, 10*60, 0), # if dry, time always 600 secs
      wet_time = ifelse(wets > 0, 10*60, 0),  # if wet, time always 600 secs
    
      bird_id = bird_id)

  return(metrics)
}

bacc_2017_metrics <- future_map_dfr(bacc_2017_files, calc_metrics)

```

Plot proportions on a heatmap per device
```{r}

plotly_bacc_2017_metrics <- plot_ly(
  data = bacc_2017_metrics,
  x = ~date, y = ~bird_id, z = ~prop_wet,
  type = "heatmap",
  colors =c("white", "blue"),
  colorbar = list(title= "Proportion Wet")
) %>%
  layout(
    title = paste("Heatmap (bin =", bin_time, "hour): Baccalieu Island - Ned Walsh (2017-2018)"),
    xaxis=list(title = "Date", tickformat = "%b %Y", tickangle = 45, tickmode = "linear", dtick="M1"),
    yaxis = list(title = "Bird ID"),
    margin = list(l = 100, b = 100, t = 50)
  )

plotly_bacc_2017_metrics

```

Aggregate bins to DAYS for visualising daily proportions, switches and wet/dry times
```{r}
calc_daily_metrics <- function(file_path) {
  deg_data <- read_csv(file_path, show_col_types=FALSE)
  
  bird_id <- str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")
  
  #start by calculating metrics for a single 2hr bin
  metrics <- deg_data %>%
    mutate(
      bin_length = bin_time * 3600, #2hrs in secs
      
      #proportion of time wet in 2hr period (wets*30 converts wetness level into secs spent wet)
      # (600sec per 10min interval) / 20 = 30 seconds per unit 
      prop_wet = (wets * 30) / bin_length, 
      
      #switches between wet (non-zero) and dry (zero) states
      switches= ifelse(row_number() == 1,0,
                       abs(diff(ifelse(wets > 0, 1, 0)))),
      
      #cumulative time spent dry (== 0) or wet (>0)
      dry_time= ifelse(wets == 0, 10*60, 0), # if dry, time always 600 secs
      wet_time = ifelse(wets > 0, 10*60, 0)  # if wet, time always 600 secs
    ) %>%
    
    #summarize the metrics for the full deployment period, grouped by day
    group_by(date) %>%
    summarize(
      bird_id = bird_id,
      total_prop_wet = sum(prop_wet, na.rm = TRUE), #take sum of proportions for daily
      total_switches = sum(switches, na.rm=TRUE),
      total_dry_time = sum(dry_time, na.rm=TRUE),
      total_wet_time = sum(wet_time, na.rm=TRUE),
      .groups="drop")
  
  return(metrics)
}

bacc_2017_daily_metrics <- future_map_dfr(bacc_2017_files, calc_daily_metrics)

bacc_2017_daily_metrics
```

##### Daily Periods

Let's use a lower resolution, down-sampling by 2hr periods instead
```{r}
(downsampled.dir <- file.path(data.dir, "downsampled_1hrs"))

#get list of downsampled files to process 
bacc_2017_files <- metrics_md %>%
  filter(colony == "Baccalieu - Ned Walsh",
         deployment_period == "2017-2018") %>%
  pull(wetdry_filename)

bacc_2017_files <- paste0("filtered_", bacc_2017_files)
 
DEG_files <- list.files(downsampled.dir, full.names=TRUE)

bacc_2017_files <- DEG_files[basename(DEG_files) %in% bacc_2017_files]

#functions to plot proportions and switches
plot_daily_metrics <- function(data, y_var, y_label, plot_title) {
  ggplot(data, aes(x = as.Date(date), y = !!sym(y_var), color = bird_id)) +
    geom_line(size = 0.2) +
    geom_point(size = 1) +
    labs(
      title = plot_title,
      x = "Time (days)",
      y = y_label,
      color = "Bird ID"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      title = element_text(size = 8),
      legend.position = "right",
      legend.direction = "vertical",
      legend.box = "vertical",
      legend.spacing.y = unit(0.2, "cm")
    ) +
    scale_x_date(
      breaks = "1 month",
      labels = scales::date_format("%b %Y")
    )
}

# Plotly plots
plotly_bacc_2017_daily_prop <- ggplotly(
  plot_daily_metrics(
    bacc_2017_daily_metrics,
    y_var = "total_prop_wet",
    y_label = "Proportion of Wet Periods (day)",
    plot_title = "Daily Proportion of Wet Periods for Baccalieu - Ned Walsh (2017-2018)"
  )
)

plotly_bacc_2017_daily_switch <- ggplotly(
  plot_daily_metrics(
    bacc_2017_daily_metrics,
    y_var = "total_switches",
    y_label = "Number of Wet-Dry Switches",
    plot_title = "Number of Switches Between Wet-Dry Periods Per Day for Baccalieu - Ned Walsh (2017-2018)"
  )
)


#Use patchwork to plot together
subplot(plotly_bacc_2017_daily_prop, plotly_bacc_2017_daily_switch,
        nrows = 2, shareX = TRUE, shareY = FALSE)
```



```{r}
#make data long to plot wetdry times together
long_bacc_2017_daily_metrics <- bacc_2017_daily_metrics %>%
  pivot_longer(cols=c(total_dry_time, total_wet_time),
               names_to = "metric",
               values_to = "time")

plot_bacc_2017_daily_dry_wet <- 
  ggplot(long_bacc_2017_daily_metrics,
         aes(x = as.Date(date),
             y = time, 
             color = metric)) +
  
  geom_line() +
  geom_point(size=0.5) +
  facet_wrap(~ bird_id, scales = "free_y") + #facets by bird ID
  labs(
    title = "Total Wet-Dry Times per Day for Gull Island (2017-2018)",
    y = "Time (seconds)",
    x = "Time (days)",
    color = "Bird ID",
    linetype = "Metric") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    title = element_text(size = 8),
    legend.position = "top"
  ) +
  scale_x_date(
    breaks = "1 month",
    labels = date_format("%b %Y"))+
  scale_color_manual(
    values = c("total_dry_time" = "lightgreen", "total_wet_time" = "darkblue"),
    labels = c("dry Time", "Wet Time"))

plotly_bacc_2017_daily_dry_wet <- ggplotly(plot_bacc_2017_daily_dry_wet) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))


plotly_bacc_2017_daily_dry_wet
```

So for these birds we see a good trend, between Dec 2017 and May 2018 there is a high proportion of wet periods. 
The total number of times the device switches from wet to dry reduces during the periods where there is a lot of wets, seems to make sense.



#### Monthly Periods

What if we group by month not day?
Will have to take an average instead of summing proportions, since it's a longer timeframe summing up proportions of wet/dry doesn't make sense. 
```{r}
calc_monthly_metrics <- function(file_path) {
  deg_data <- read_csv(file_path, show_col_types=FALSE)
  
  bird_id <- str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")
  
  #start by calculating metrics for a single 2hr bin
  metrics <- deg_data %>%
    mutate(
      bin_length = 7200, #2hrs in secs
      
      #proportion of time wet in 2hr period (wets*30 converts wetness level into secs spent wet)
      # (600sec per 10min interval) / 20 = 30 seconds per unit 
      prop_wet = (wets * 30) / bin_length, 
      
      #switches between wet (non-zero) and dry (zero) states
      switches= ifelse(row_number() == 1,0,
                       abs(diff(ifelse(wets > 0, 1, 0)))),
      
      #cumulative time spent dry (== 0) or wet (>0)
      dry_time= ifelse(wets == 0, 10*60, 0), # if dry, time always 600 secs
      wet_time = ifelse(wets > 0, 10*60, 0),  # if wet, time always 600 secs
      
      #add to consider months
      month = floor_date(as.Date(date), unit = "month")
    ) %>%
    
    #summarize the metrics for the full deployment period, grouped by day
    group_by(month) %>%
    summarize(
      bird_id = bird_id,
      avg_prop_wet = mean(prop_wet, na.rm = TRUE), #take avg prop wet for monthly 
      total_switches = sum(switches, na.rm=TRUE),
      total_dry_time = sum(dry_time, na.rm=TRUE),
      total_wet_time = sum(wet_time, na.rm=TRUE),
      .groups = "drop" #ungroup after summarizing
      )
  
  return(metrics)
}

bacc_2017_monthly_metrics <- future_map_dfr(bacc_2017_files, calc_monthly_metrics)

bacc_2017_monthly_metrics

plot_bacc_2017_monthly_prop <- ggplot(bacc_2017_monthly_metrics, aes(x = as.Date(month),
                                                         y = avg_prop_wet,
                                                         color = bird_id)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Avg Proportion of Wet Periods per Month",
    y = "Proportion of period (day)",
    x = "Time (months)",
    color = "Bird ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    title = element_text(size = 8),
    legend.position = "none") +
  scale_x_date(
    breaks = "1 month",
    labels = date_format("%b %Y")
  )


plot_bacc_2017_monthly_switch <- ggplot(bacc_2017_monthly_metrics, aes(x = as.Date(month), 
                                                           y = total_switches, 
                                                           color = bird_id)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Total Switches Between Wet-Dry Per Day",
    y = "Number of switches",
    x = "Time (months)",
    color = "Bird ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    title = element_text(size = 8),
    legend.position = "right",
    legend.direction = "vertical",
    legend.box = "vertical",
    legend.spacing.y = unit(0.2, "cm")
  ) +
  scale_x_date(
    breaks = "1 month",
    labels = date_format("%b %Y")
  )


#turn into plotly objects
plotly_bacc_2017_monthly_prop <- ggplotly(plot_bacc_2017_monthly_prop) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))

plotly_bacc_2017_monthly_switch <- ggplotly(plot_bacc_2017_monthly_switch) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))

subplot(plotly_bacc_2017_monthly_prop, plotly_bacc_2017_monthly_switch,
        nrows = 2, shareX = TRUE, shareY = FALSE)


```


### Longest Wet/Dry Periods
We can also consider the two hour periods and not fiddle around with summing up every metric by days
this would give us a finer resolution for looking at things like the longest period the device was wet/dry.

**Working notes:**
`at first I tried to calc Longest periods of wet (1-20), very wet (>15) and entriely wet (== 20), but I realised that doesn't make a lot of sense. We want to analyse sustained periods the bird was wet we shouldn't have to consider very wet or entirely wet. Instead I try to identify the start and end times of the longest sustained wet period for each bird`.

Here I use `rle()` (run length encoding) to find cnosecutive runs of vals above 0 or equal to 20.
This produces a vector `values` made up of TRUE/FALSE vals, and `lengths` which tracks the number of TRUE/FALSE vals occurring in a row.

  example // 
    vec <- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE)
    len = c(2,3,3,1)


```{r}
calc_longest_wet_prds <- function(file_path) {
  
  deg_data <- read_csv(file_path, show_col_types = FALSE)
  
  #add a datetime_start column
  deg_data <- deg_data %>%
    mutate(datetime_start = as.POSIXct(paste(date, start_time), format = "%Y-%m-%d %H:%M:%S"))
  
  # define bird IDs
  bird_id <- str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")

  # ================================
  # Calculate longest periods (wets > 0)
  # Where the bird was wet at least once in a 2-hour bin
  # ================================
  
  rle_wet <- rle(deg_data$wets > 0)
  longest_wet = max(rle_wet$lengths[rle_wet$values]) #longest run of wets>0 from lengths of vals
  total_wet_duration <- longest_wet * 2 #convert 2hr bins to total hrs
  
  #find when the end and start of longest TRUE prd in the datasets
  end_file <- cumsum(rle_wet$lengths)[ #cumul. sum of bin lengths for run end index
    which.max(rle_wet$lengths[rle_wet$values])] #index = longest period
  start_file <- end_file - longest_wet +1 #just subtract # of bins in wet prd
  
  datetime_start_wet <- deg_data$datetime_start[start_file]
  datetime_end_wet <- deg_data$datetime_start[end_file]
  
  
  # ================================
  # Calculate longest periods (wets == 20)
  # Where the bird was wet for the entire 2-hour bin.
  # ================================
  rle_max_wet <- rle(deg_data$wets == 20)
  longest_max_wet <- max(rle_max_wet$lengths[rle_wet$values])
  total_max_wet_duration <- longest_max_wet * 2
    
  end_file <- cumsum(rle_max_wet$lengths)[which.max(rle_max_wet$lengths[rle_max_wet$values])] 
  start_file <- end_file - longest_wet +1 
  
  datetime_start_maxwet <- deg_data$datetime_start[start_file]
  datetime_end_maxwet <- deg_data$datetime_start[end_file]
  
    
  # ================================
  # Calculate longest periods (wets == 0)
  # Where the bird remained dry for the 2-hour bins.
  # ================================
  rle_dry <- rle(deg_data$wets == 0)
  longest_dry <- max(rle_dry$lengths[rle_dry$values])
  total_dry_duration <- longest_dry * 2
    
  end_file <- cumsum(rle_dry$lengths)[which.max(rle_dry$lengths[rle_dry$values])] 
  start_file <- end_file - longest_dry +1 
  
  datetime_start_dry <- deg_data$datetime_start[start_file]
  datetime_end_dry <- deg_data$datetime_start[end_file]
  
  
  #return dataframe
  return(data.frame(
    bird_id = bird_id,
    longest_wet = total_wet_duration, # hours
    longest_entirely_wet = total_max_wet_duration, # hours
    datetime_start_wet = datetime_start_wet,
    datetime_end_wet = datetime_end_wet,
    datetime_start_maxwet = datetime_start_maxwet,
    datetime_end_maxwet = datetime_end_maxwet,
    datetime_start_dry = datetime_start_dry,
    datetime_end_dry = datetime_end_dry
  ))
}



# run on gull 2017-2018 files
bacc_2017_longest_wet_prds <- future_map_dfr(bacc_2017_files, calc_longest_wet_prds)
```


```{r}
#timeline plot to visualize longest wet periods for birds on Gull Island 2017-2018
plot_bacc_2017_longest_prds <- ggplot(bacc_2017_longest_wet_prds, aes(y=bird_id)) +

  geom_segment(aes(x = datetime_start_maxwet,
                   xend = datetime_end_maxwet,
                   yend= bird_id, color = bird_id,linetype="solid"),
               size = 1) +
  
  geom_segment(aes(x = datetime_start_dry,
                   xend = datetime_end_dry,
                   yend= bird_id, color = bird_id,linetype="dotted"),
               size = 1) +
  
      labs(title = "Longest Wet Periods for Baccalieu Island - Ned Walsh (2017-2018)",
           subtitle = "Dotted: Wet at least once in 2-hour bin | Solid: Entirely wet in 2-hour bin",
           x = "Time", y = "Bird ID", color = "Bird ID") +
  
  scale_x_datetime(breaks = "1 month", labels = date_format("%b %Y")) +
  theme(axis.text.y = element_text(size = 10),plot.title = element_text(hjust = 0.5, face = "bold"))
  
plot_bacc_2017_longest_prds
```


#### Wet-Dry Full Deployment


Lastly, let's look at all of the wet and dry periods throughout the entire deployment time so we can visualise how they change over time an dmaybe see when those really long periods of entirely wet are

```{r}

prepare_plot_data <- function(file_path) {
  deg_data <- read_csv(file_path, show_col_types = FALSE) %>%
      mutate(
      datetime_start = as.POSIXct(paste(date, start_time), format = "%Y-%m-%d %H:%M:%S"),
      bird_id = str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")
    ) %>%
    
    #aggregate the data into 6 hr bins from 2 hr bins
    group_by(bird_id, time_window = as.Date(datetime_start)) %>%
    summarize(avg_wets = mean(wets, na.rm=TRUE), .groups = "drop")
  return(deg_data)
}

plot_data <- bacc_2017_files %>%
  lapply(prepare_plot_data) %>%
  bind_rows()

#plot data for all wets durign deployment periods
plot_all_wet_periods <- ggplot(plot_data, aes(x=time_window, y=avg_wets, color=bird_id)) +
  geom_line() +
  labs(
    title = "Dry and Wet Periods for Baccalieu Island - Ned Walsh (2017-2018)",
    x= "Time (2hr intervals)",
    y= "Wetness",
    color = "Bird ID") +
  scale_y_continuous(
    breaks = seq(0, 20, 5)) +
  theme_minimal() +
    scale_x_datetime(breaks = "1 month", labels = date_format("%b %Y"))


plotly_bacc_2017_all_wet <- ggplotly(plot_all_wet_periods) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))

plotly_bacc_2017_all_wet
```


