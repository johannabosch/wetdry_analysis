# Wet-Dry Metrics


## Load settings

```{r include=FALSE}
source(here::here("project_settings.R"), echo=TRUE)
```


## Down-sampling 

Right now the files are logging every 10 minutes, which is too high of a resolution. Need to down-sample the dataset from 10min to some other interval that is meaningful to define states to.

12hrs seems too long given how far birds can move in this time, but 10min is far too short.

Tempted to use 2hr resolution to match GPS. 
For example, within each 2hr period we need to assess:

•	Proportion wet or time wet ((Count wets in 2hr period * 30sec) / 72000sec)
•	Number of switches between 0 and non-zero value
•	Total time when entire 10min sampling interval was dry (count 0s * 10min)
•	Total time when entire 10min sampling interval was wet (count >=1 * 10min)
•	Longest continuous time dry (longest number of consecutive rows with wets==0  * 10min)
•	Longest continuous time wet (longest number of consecutive rows with wets>=1 * 10min)

### 2hr Periods

```{r eval=FALSE}
if (FALSE) {
#made a new dir called downsampled in /data
source(here("utils/downsample_deg.R"), echo = F)

#define deg files to use
deg_files <- list.files(output.dir, pattern = "*.deg", full.names = TRUE)#[1:5] #add if you want to subset

#set up a furrr plan for using 4 cores
plan(multisession, workers = 4)

future_map(deg_files, downsample_deg)

plan(sequential)
}

```


This is what the deg files look like now:
```
date,start_time,end_time,wets
2022-09-08,00:00:00,01:59:59,0
2022-09-08,02:00:00,03:59:59,0
2022-09-08,04:00:00,05:59:59,0
2022-09-08,06:00:00,07:59:59,...
```


So our dataset's `wets` values now represent the average number of 10-minute intervals that were wet during the 2-hour period. This means each 2hr period has 12 intervals of 10 minutes (600 secs).

wets = 0 means 10min interval was entirely wet
wets = 20 means 10min interval was entirely dry

For one 10min interval,
if wets=1, then 600s/20 = 30 seconds
so 1 unit wets = 30 seconds wet per 10min interval

## Reviewing Metadata

Make a table to review how many files we have per deployment period per colony:
```{r}
md <- read.csv(file.path(data.dir, "MasterMetadata_LHSP_Tracking_NL_NB_NS_13Aug2024.csv"))

colnames(md)

#clean up the metadata so that we only include the necessary columns for clipping
metrics_md <- md %>%
  
  filter(
    #filter for MT devices
    tagMake %in% c("Migrate Technology: W30A9-SEA", "Migrate Technology: W30A9-SEA-COOL"),
    #remove any NA rows in wetdry_filename 
    !is.na(wetdry_filename)) %>% 
  
  # merge estimated and observed columns 
  mutate(
    depDate_comb = as.Date(ifelse(!is.na(dep_dateEst), dep_dateEst, dep_date), format = "%Y-%m-%d"),
    retDate_comb = as.Date(
      ifelse(!is.na(ret_dateEst), substr(ret_dateEst, nchar(ret_dateEst) - 9, nchar(ret_dateEst)), 
             ret_date), format = "%Y-%m-%d")) %>%
  
  mutate(depDate_comb = as.Date(depDate_comb),
         retDate_comb = as.Date(retDate_comb)) %>%
  
  #only keep necessary columns 
  select(wetdry_filename, depDate_comb, retDate_comb, colony) %>%
  
  #fix fomratted name for that one DEG file i manually changed
  mutate(wetdry_filename = ifelse(
      wetdry_filename == "BH594_04Jul18_135310driftadj.deg",
      "BH594_formatted_04Jul18_135310driftadj.deg",
      wetdry_filename))  %>%
  
  #categorize deployment periods in the dtaaframe
  mutate(
    deployment_period = case_when(
      depDate_comb >= as.Date("2017-01-01") & depDate_comb < as.Date("2019-01-01") ~ "2017-2018",
      depDate_comb >= as.Date("2018-01-01") & depDate_comb < as.Date("2020-01-01") ~ "2018-2019",
      depDate_comb >= as.Date("2019-01-01") & depDate_comb < as.Date("2021-01-01") ~ "2019-2020",
      depDate_comb >= as.Date("2020-01-01") & depDate_comb < as.Date("2022-01-01") ~ "2020-2021",
      depDate_comb >= as.Date("2021-01-01") & depDate_comb < as.Date("2023-01-01") ~ "2021-2022",
      depDate_comb >= as.Date("2022-01-01") & depDate_comb < as.Date("2024-01-01") ~ "2022-2023",
      TRUE ~ "Other"   # any records outside of these ranges
    )
  )

deployment_summary <- metrics_md %>%
  
  group_by(deployment_period, colony) %>%
  
  summarise(file_count=n(), .groups = "drop") %>%
  
  pivot_wider(names_from = colony,  #make tibble with colony columns
              values_from = file_count, 
              values_fill = 0 # fill missing vals with 0
              ) %>%
  mutate(TOTAL = rowSums(select(., -deployment_period))) %>%
  
  bind_rows(summarise(.,
                      across(where(is.numeric), sum),
                      deployment_period = "TOTAL"))

deployment_summary

```


We want the following metrics for times the device was deployed:

* **Total proportion of time wet:** proportion of seconds wet across all 2-hour bins for the day, where (count of wets in each bin * 30 seconds) / 7200 seconds.

* **Total number of state switches (wet/dry transitions) per day:** number of times the device switched between wet (non-zero) and dry (zero) states across all 2-hour bins.

* **Cumulative dry and wet times per day:** total time (in seconds) the device recorded as completely dry (wets == 0) or wet (wets > 0) during the sampling intervals within the day.

* **Longest continuous periods of dry or wet states throughout the whoel deployment period:** longest sequence of consecutive 10-minute intervals within the entire deployment period where the device recorded



## Gull Island 2017-2018

Let's start with the 2017-2018 files from Gull (10 files total)
```{r}
#get list of downsampled files to process 
gull_2017_files <- metrics_md %>%
  filter(colony == "Gull", deployment_period == "2017-2018") %>%
  pull(wetdry_filename)

gull_2017_files <- paste0("filtered_", gull_2017_files)
 
DEG_files <- list.files(downsampled.dir, full.names=TRUE)

gull_2017_files <- DEG_files[basename(DEG_files) %in% gull_2017_files]
```


Function to calculate DAILY proportions, switches and wet/dry times
```{r}
calc_daily_metrics <- function(file_path) {
  deg_data <- read_csv(file_path, show_col_types=FALSE)
  
  bird_id <- str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")
  
  #start by calculating metrics for a single 2hr bin
  metrics <- deg_data %>%
    mutate(
      bin_length = 7200, #2hrs in secs
      
      #proportion of time wet in 2hr period (wets*30 converts wetness level into secs spent wet)
      # (600sec per 10min interval) / 20 = 30 seconds per unit 
      prop_wet = (wets * 30) / bin_length, 
      
      #switches between wet (non-zero) and dry (zero) states
      switches= ifelse(row_number() == 1,0,
                       abs(diff(ifelse(wets > 0, 1, 0)))),
      
      #cumulative time spent dry (== 0) or wet (>0)
      dry_time= ifelse(wets == 0, 10*60, 0), # if dry, time always 600 secs
      wet_time = ifelse(wets > 0, 10*60, 0)  # if wet, time always 600 secs
    ) %>%
    
    #summarize the metrics for the full deployment period, grouped by day
    group_by(date) %>%
    summarize(
      bird_id = bird_id,
      total_prop_wet = sum(prop_wet, na.rm = TRUE), #take sum of proportions for daily
      total_switches = sum(switches, na.rm=TRUE),
      total_dry_time = sum(dry_time, na.rm=TRUE),
      total_wet_time = sum(wet_time, na.rm=TRUE),
      )
  
  return(metrics)
}
```

```{r}
gull_2017_daily_metrics <- future_map_dfr(gull_2017_files, calc_daily_metrics)

gull_2017_daily_metrics
```

##### Daily Proportions/Switches

```{r}

plot_gull_2017_prop <- ggplot(gull_2017_daily_metrics, aes(x = as.Date(date), y = total_prop_wet, color = bird_id)) +
  geom_line(size = 0.2) +
  geom_point(size = 1) +
  labs(
    title = "Total Proportion of Wet Periods per Day for Gull Island (2017-2018)",
    y = "Proportion of period (day)",
    x = "Time (days)",
    color = "Bird ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    title = element_text(size = 8),
    legend.position = "right",
    legend.direction = "vertical",
    legend.box = "vertical",
    legend.spacing.y = unit(0.2, "cm"))+
  scale_x_date(
    breaks = "1 month",
    labels = date_format("%b %Y")
  )

plotly_gull_2017_daily_prop <- ggplotly(plot_gull_2017_prop) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))


```

```{r}
plot_gull_2017_switch <- ggplot(gull_2017_daily_metrics, aes(x = as.Date(date), y = total_switches, color = bird_id)) +
  geom_line(size=0.2) +
  geom_point(size=1) +
  labs(
    title = "Total Switches Between Wet-Dry Per Day for Gull Island (2017-2018)",
    y = "Number of switches",
    x = "Time (days)",
    color = "Bird ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    title = element_text(size = 8),
    legend.position = "right",
    legend.direction = "vertical",
    legend.box = "vertical",
    legend.spacing.y = unit(0.2, "cm")
  ) +
  scale_x_date(
    breaks = "1 month",
    labels = date_format("%b %Y")
  )

plotly_gull_2017_daily_switch <- ggplotly(plot_gull_2017_switch) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))

```

Use patchwork to plot together
```{r}
subplot(plotly_gull_2017_prop, plotly_gull_2017_switch,
        nrows = 2, shareX = TRUE, shareY = FALSE)
```



```{r}
#make data long to plot wetdry times together
long_gull_2017_daily_metrics <- gull_2017_daily_metrics %>%
  pivot_longer(cols=c(total_dry_time, total_wet_time),
               names_to = "metric",
               values_to = "time")

plot_gull_2017_daily_dry_wet <- 
  ggplot(long_gull_2017_daily_metrics,
         aes(x = as.Date(date),
             y = time, 
             color = bird_id, 
             linetype = metric)) +
  
  geom_line() +
  geom_point() +
  labs(
    title = "Total Wet-Dry Times per Day for Gull Island (2017-2018)",
    y = "Time (seconds)",
    x = "Time (days)",
    color = "Bird ID",
    linetype = "Metric") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    title = element_text(size = 8),
    legend.position = "right"
  ) +
  scale_x_date(
    breaks = "1 month",
    labels = date_format("%b %Y"))+
  scale_linetype_manual(
    values = c("total_dry_time" = "dashed", "total_wet_time" = "solid"),
    labels = c("dry Time", "Wet Time"))

plotly_gull_2017_daily_dry_wet <- ggplotly(plot_gull_2017_daily_dry_wet) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))
```

So for these birds we see a good trend, between Dec 2017 and May 2018 there is a high proportion of wet periods. 
The total number of times the device switches from wet to dry reduces during the periods where there is a lot of wets, seems to make sense.

#### Monthly 

What if we group by month not day?
Will have to take an average instead of summing proportions, since it's a longer timeframe summing up proportions of wet/dry doesn't make sense. 
```{r}
calc_monthly_metrics <- function(file_path) {
  deg_data <- read_csv(file_path, show_col_types=FALSE)
  
  bird_id <- str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")
  
  #start by calculating metrics for a single 2hr bin
  metrics <- deg_data %>%
    mutate(
      bin_length = 7200, #2hrs in secs
      
      #proportion of time wet in 2hr period (wets*30 converts wetness level into secs spent wet)
      # (600sec per 10min interval) / 20 = 30 seconds per unit 
      prop_wet = (wets * 30) / bin_length, 
      
      #switches between wet (non-zero) and dry (zero) states
      switches= ifelse(row_number() == 1,0,
                       abs(diff(ifelse(wets > 0, 1, 0)))),
      
      #cumulative time spent dry (== 0) or wet (>0)
      dry_time= ifelse(wets == 0, 10*60, 0), # if dry, time always 600 secs
      wet_time = ifelse(wets > 0, 10*60, 0),  # if wet, time always 600 secs
      
      #add to consider months
      month = floor_date(as.Date(date), unit = "month")
    ) %>%
    
    #summarize the metrics for the full deployment period, grouped by day
    group_by(month) %>%
    summarize(
      bird_id = bird_id,
      avg_prop_wet = mean(prop_wet, na.rm = TRUE), #take avg prop wet for monthly 
      total_switches = sum(switches, na.rm=TRUE),
      total_dry_time = sum(dry_time, na.rm=TRUE),
      total_wet_time = sum(wet_time, na.rm=TRUE),
      .groups = "drop" #ungroup after summarizing
      )
  
  return(metrics)
}

gull_2017_monthly_metrics <- future_map_dfr(gull_2017_files, calc_monthly_metrics)

gull_2017_monthly_metrics

plot_gull_2017_monthly_prop <- ggplot(gull_2017_monthly_metrics, aes(x = as.Date(month),
                                                         y = avg_prop_wet,
                                                         color = bird_id)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Avg Proportion of Wet Periods per Month",
    y = "Proportion of period (day)",
    x = "Time (months)",
    color = "Bird ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    title = element_text(size = 8),
    legend.position = "none") +
  scale_x_date(
    breaks = "1 month",
    labels = date_format("%b %Y")
  )


plot_gull_2017_monthly_switch <- ggplot(gull_2017_monthly_metrics, aes(x = as.Date(month), 
                                                           y = total_switches, 
                                                           color = bird_id)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Total Switches Between Wet-Dry Per Day",
    y = "Number of switches",
    x = "Time (months)",
    color = "Bird ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    title = element_text(size = 8),
    legend.position = "right",
    legend.direction = "vertical",
    legend.box = "vertical",
    legend.spacing.y = unit(0.2, "cm")
  ) +
  scale_x_date(
    breaks = "1 month",
    labels = date_format("%b %Y")
  )


#turn into plotly objects
plotly_gull_2017_monthly_prop <- ggplotly(plot_gull_2017_monthly_prop) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))

plotly_gull_2017_monthly_switch <- ggplotly(plot_gull_2017_monthly_switch) %>%
  layout(margin = list(l =50, r=50, b=100, t=50),
         xaxis = list(tickangle=45))

subplot(plotly_gull_2017_monthly_prop, plotly_gull_2017_monthly_switch,
        nrows = 2, shareX = TRUE, shareY = FALSE)


```


### Longest Wet/Dry Periods
We can also consider the two hour periods and not fiddle around with summing up every metric by days
this would give us a finer resolution for looking at things like the longest period the device was wet/dry.

**Working notes:**
`at first I tried to calc Longest periods of wet (1-20), very wet (>15) and entriely wet (== 20), but I realised that doesn't make a lot of sense. We want to analyse sustained periods the bird was wet we shouldn't have to consider very wet or entirely wet. Instead I try to identify the start and end times of the longest sustained wet period for each bird`.

Here I use `rle()` (run length encoding) to find cnosecutive runs of vals above 0 or equal to 20.
This produces a vector `values` made up of TRUE/FALSE vals, and `lengths` which tracks the number of TRUE/FALSE vals occurring in a row.

  example // 
    vec <- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE)
    len = c(2,3,3,1)


```{r}
calc_longest_wet_prds <- function(file_path) {
  
  deg_data <- read_csv(file_path, show_col_types = FALSE)
  
  #add a datetime_start column
  deg_data <- deg_data %>%
    mutate(datetime_start = as.POSIXct(paste(date, start_time), format = "%Y-%m-%d %H:%M:%S"))
  
  # define bird IDs
  bird_id <- str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")

  # ================================
  # Calculate longest periods (wets > 0)
  # Where the bird was wet at least once in a 2-hour bin
  # ================================
  
  rle_wet <- rle(deg_data$wets > 0)
  longest_wet = max(rle_wet$lengths[rle_wet$values]) #longest run of wets>0 from lengths of vals
  total_wet_duration <- longest_wet * 2 #convert 2hr bins to total hrs
  
  #find when the end and start of longest TRUE prd in the datasets
  end_file <- cumsum(rle_wet$lengths)[ #cumul. sum of bin lengths for run end index
    which.max(rle_wet$lengths[rle_wet$values])] #index = longest period
  start_file <- end_file - longest_wet +1 #just subtract # of bins in wet prd
  
  datetime_start_wet <- deg_data$datetime_start[start_file]
  datetime_end_wet <- deg_data$datetime_start[end_file]
  
  
    # ================================
  # Calculate longest periods (wets == 20)
  # Where the bird was wet for the entire 2-hour bin.
  # ================================
  rle_max_wet <- rle(deg_data$wets == 20)
  longest_max_wet <- max(rle_max_wet$lengths[rle_wet$values])
  total_max_wet_duration <- longest_max_wet * 2
    
  end_file <- cumsum(rle_max_wet$lengths)[which.max(rle_max_wet$lengths[rle_max_wet$values])] 
  start_file <- end_file - longest_wet +1 
  
  datetime_start_maxwet <- deg_data$datetime_start[start_file]
  datetime_end_maxwet <- deg_data$datetime_start[end_file]
  
  
  #return dataframe
  return(data.frame(
    bird_id = bird_id,
    longest_wet = total_wet_duration, # hours
    longest_entirely_wet = total_max_wet_duration, # hours
    datetime_start_wet = datetime_start_wet,
    datetime_end_wet = datetime_end_wet,
    datetime_start_maxwet = datetime_start_maxwet,
    datetime_end_maxwet = datetime_end_maxwet
  ))
}

gull_2017_longest_wet_prds <- future_map_dfr(gull_2017_files, calc_longest_wet_prds)


```

Lastly, let's look at all of the wet and dry periods throughout the entire deployment time so we can visualise how they change over time an dmaybe see when those really long periods of entirely wet are

```{r}

prepare_plot_data <- function(file_path) {
  deg_data <- read_csv(file_path, show_col_types = FALSE) %>%
      mutate(
      datetime_start = as.POSIXct(paste(date, start_time), format = "%Y-%m-%d %H:%M:%S"),
      bird_id = str_extract(basename(file_path), "(?<=filtered_)[A-Z-0-9]{5}")
    )
  return(deg_data)
}

plot_data <- example_birds %>%
  lapply(prepare_plot_data) %>%
  bind_rows()

plot_all_wet_periods <- ggplot(plot_data, aes(x=datetime_start, y=wets, color=bird_id)) +
  geom_line() +
  labs(
    title = "Dry and Wet Periods Over Entire Deployment Period",
    x= "Time (2hr intervals)",
    y= "Wetness",
    color = "Bird ID") +
  scale_y_continuous(
    breaks = seq(0, 20, 5)) +
  theme_minimal()



```


Okkkk thats fun

ii shoudl look into how takign the average for every two hr period here impacts this 

maybe i shouldnt be binning that way

will look into different ways of handlig wets, maybe just leave at 10mins? but this resolution is already too high 

what im doign now
binning wets by 2 hours, taking average of wets to bin them here

then im considering wets/dries for that entire deployment period (each point = 2hrs)
but im also considering full daily metrics inside of that which probably isnt a great approach - look into binnig daily first instead of by 2hrs with average and then daily.


